"""CVE-2018-17144: Bitcoin Core Inflation Vulnerability

This vulnerability allows miners to inflate Bitcoin supply by creating
transactions that spend the same input twice. The duplicate-input check
was removed in PR #9049 as an optimization.

Reference: https://bitcoincore.org/en/2018/09/20/notice/
Reference: https://github.com/bitcoin/bitcoin/pull/14247

Affected: Bitcoin Core 0.14.0 - 0.16.2
Severity: CRITICAL (9.0+ CVSS)
"""

import asyncio
import struct

from minesploit.framework import Exploit, ExploitMeta, ExploitResult

VULNERABLE_VERSIONS = {
    (0, 14): (0, 14),
    (0, 15): (0, 15),
    (0, 16): (0, 16, 0),
}


class CVE_2018_17144_INFLATION(Exploit):
    meta = ExploitMeta(
        name="CVE-2018-17144: Bitcoin Core Inflation Vulnerability",
        cve="CVE-2018-17144",
        cvss_score=9.0,
        severity="CRITICAL",
        affected_versions="Bitcoin Core 0.14.0 - 0.16.2",
        discovered_by="Awemany",
        disclosure_date="2018-09-20",
        description=(
            "Bitcoin Core before 0.16.3 allows miners to inflate supply by creating "
            "transactions that spend the same input twice. The duplicate-input check "
            "was removed in PR #9049 as an optimization, but blocks received via "
            "compact block relay bypass mempool validation."
        ),
        references=[
            "https://bitcoincore.org/en/2018/09/20/notice/",
            "https://github.com/bitcoin/bitcoin/pull/14247",
        ],
    )

    def __init__(self):
        super().__init__()

    def _parse_version(self, payload: bytes) -> tuple[int, int, int]:
        try:
            version = struct.unpack("<I", payload[:4])[0]
            major = (version >> 16) & 0xFFFF
            minor = (version >> 8) & 0xFF
            patch = version & 0xFF
            return (major, minor, patch)
        except Exception:
            return (0, 0, 0)

    def _is_vulnerable(self, version_tuple: tuple[int, int, int]) -> bool:
        major, minor, patch = version_tuple

        if major == 0:
            if minor == 14:
                return True
            elif minor == 15:
                return True
            elif minor == 16:
                return patch <= 2
        return False

    def _create_version_message(self, version: int = 70015) -> bytes:
        magic = b"\xf9\xbe\xb4\xd9"
        command = b"version\x00\x00\x00\x00\x00"

        payload = struct.pack("<I", version)
        payload += b"\x00" * 8
        payload += struct.pack("<Q", 0)
        payload += b"\x00" * 10
        payload += struct.pack("<Q", 0)
        payload += b"\x00" * 8
        payload += b"\x00"
        payload += b"\x00" * 10
        payload += b"\x00" * 24

        checksum = b"\x00\x00\x00\x00"

        return magic + command + struct.pack("<I", len(payload)) + checksum + payload

    async def check(self, target: str, port: int = 8333, **kwargs) -> ExploitResult:
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(target, port),
                timeout=10.0,
            )

            version_msg = self._create_version_message()
            writer.write(version_msg)
            await writer.drain()

            response = await asyncio.wait_for(reader.read(4096), timeout=10.0)

            writer.close()
            await writer.wait_closed()

            if not response or len(response) < 48:
                return ExploitResult(False, "No valid Bitcoin Core response")

            if b"version" in response[12:20]:
                return ExploitResult(
                    True,
                    "Bitcoin Core node detected - version detection requires deeper parsing",
                    {"service": "bitcoind", "note": "Manual version check recommended"},
                )

            return ExploitResult(False, "Not a Bitcoin Core node")

        except asyncio.TimeoutError:
            return ExploitResult(False, "Connection timed out")
        except ConnectionRefusedError:
            return ExploitResult(False, "Connection refused")
        except Exception as e:
            return ExploitResult(False, f"Error: {str(e)}")

    async def exploit(
        self,
        target: str,
        port: int = 8333,
        **kwargs,
    ) -> ExploitResult:
        return ExploitResult(
            False,
            "Exploitation requires mining capability",
            {
                "reason": "CVE-2018-17144 requires the ability to create blocks",
                "note": "Only mining nodes can create blocks with double-spending transactions",
                "requirements": [
                    "Mining hashrate or co-operation with existing miner",
                    "Ability to include arbitrary transactions in blocks",
                    "Knowledge of previous block's coinbase output to double-spend",
                ],
                "reference": ("https://bitcoincore.org/en/2018/09/20/notice/"),
            },
        )

    async def verify(self, target: str, port: int = 8333, **kwargs) -> ExploitResult:
        return ExploitResult(
            True,
            "Verification requires checking blockchain state for inflation",
            {
                "method": "Compare total coin supply against expected emission schedule",
                "note": "This requires historical chain analysis, not just node interaction",
            },
        )

