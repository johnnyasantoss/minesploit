"""CVE-2025-46598: Bitcoin Core CPU DoS from unconfirmed transaction processing

This vulnerability allows remote attackers to cause CPU exhaustion on Bitcoin Core
nodes via specially crafted non-standard transactions that trigger quadratic hashing
during signature verification.

Reference: https://bitcoincore.org/en/2025/10/24/disclose-cve-2025-46598/

Affected: Bitcoin Core < 30.0
Fixed In: Bitcoin Core 30.0 (October 10, 2025)
Severity: LOW (5.3 CVSS)
"""

import asyncio
import re

from minesploit.framework import Exploit, ExploitMeta, ExploitResult


class CVE_2025_46598_CPU_TX_DOS(Exploit):
    meta = ExploitMeta(
        name="CVE-2025-46598: Bitcoin Core CPU Transaction DoS",
        cve="CVE-2025-46598",
        cvss_score=5.3,
        severity="LOW",
        affected_versions="Bitcoin Core < 30.0",
        discovered_by="Antoine Poinsot",
        disclosure_date="2025-10-24",
        description=(
            "Bitcoin Core before 30.0 allows remote attackers to cause CPU exhaustion "
            "via specially crafted non-standard transactions that trigger expensive "
            "signature verification operations (quadratic hashing). Transactions are "
            "rejected but the peer is not disconnected, allowing indefinite attack repetition."
        ),
        references=[
            "https://bitcoincore.org/en/2025/10/24/disclose-cve-2025-46598/",
        ],
    )

    def __init__(self):
        super().__init__()

    def _parse_version(self, version_string: str) -> tuple[int, ...]:
        match = re.search(r"(\d+)\.(\d+)\.(\d+)", version_string)
        if match:
            return tuple(int(x) for x in match.groups())
        return (0,)

    def _is_vulnerable(self, version: tuple[int, ...]) -> bool:
        if len(version) < 1:
            return True
        if version[0] < 30:
            return True
        return False

    async def check(self, target: str, port: int = 8333, **kwargs) -> ExploitResult:
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(target, port),
                timeout=10.0,
            )

            version_msg = self._create_version_message()
            writer.write(version_msg)
            await writer.drain()

            response = await asyncio.wait_for(reader.read(4096), timeout=10.0)
            writer.close()
            await writer.wait_closed()

            if not response:
                return ExploitResult(False, "No response from target")

            response_text = response.decode("latin-1", errors="ignore")

            if "version" in response_text.lower():
                version_match = re.search(
                    r"/(?: Satoshi:|)[^:]*:(\d+)\.(\d+)\.(\d+)", response_text
                )
                if version_match:
                    version = tuple(int(x) for x in version_match.groups())
                    is_vulnerable = self._is_vulnerable(version)
                    version_str = ".".join(str(x) for x in version)

                    if is_vulnerable:
                        return ExploitResult(
                            True,
                            f"Vulnerable Bitcoin Core {version_str} detected (version < 30.0)",
                            {"vulnerable": True, "version": version_str},
                        )
                    else:
                        return ExploitResult(
                            False,
                            f"Bitcoin Core {version_str} is not vulnerable (>= 30.0)",
                            {"vulnerable": False, "version": version_str},
                        )

                return ExploitResult(
                    True,
                    "Bitcoin Core node detected (version unknown)",
                    {"vulnerable": True, "version": "unknown"},
                )

            return ExploitResult(False, "Unknown service response")

        except asyncio.TimeoutError:
            return ExploitResult(False, "Connection timed out")
        except ConnectionRefusedError:
            return ExploitResult(False, "Connection refused")
        except Exception as e:
            return ExploitResult(False, f"Error: {str(e)}")

    def _create_version_message(self) -> bytes:
        import struct

        magic = b"\xf9\xbe\xb4\xd9"
        command = b"version\x00\x00\x00\x00\x00"

        payload = struct.pack("<I", 70015)
        payload += b"\x00" * 8
        payload += struct.pack("<Q", 0)
        payload += b"\x00" * 10
        payload += struct.pack("<Q", 0)
        payload += b"\x00" * 8
        payload += b"\x00"
        payload += b"\x00" * 10
        payload += b"\x00" * 24

        checksum = b"\x00\x00\x00\x00"

        return magic + command + struct.pack("<I", len(payload)) + checksum + payload

    async def exploit(
        self,
        target: str,
        port: int = 8333,
        **kwargs,
    ) -> ExploitResult:
        check_result = await self.check(target, port, **kwargs)

        if not check_result.success or not check_result.details.get("vulnerable", False):
            return ExploitResult(
                False,
                "Target is not vulnerable or version could not be determined",
            )

        return ExploitResult(
            True,
            (
                f"Exploit requires sending specially crafted non-standard transactions. "
                f"Target {target}:{port} running vulnerable Bitcoin Core. "
                f"See CVE-2025-46598 for transaction crafting details."
            ),
            {"sent": False, "note": "Manual exploit required"},
        )

    async def verify(self, target: str, port: int = 8333, **kwargs) -> ExploitResult:
        return ExploitResult(
            True,
            "Version detection is the primary verification method",
        )
