"""CVE-2015-20111: miniupnpc Remote Code Execution

This vulnerability allows remote attackers on the local network to execute arbitrary
code via a buffer overflow in the miniupnpc library when UPnP is enabled.

Reference: https://bitcoincore.org/en/2024/07/03/disclose_upnp_rce/
Reference: https://nvd.nist.gov/vuln/detail/CVE-2015-20111

Affected: Bitcoin Core < 0.12.0 (with UPnP enabled)
Severity: MEDIUM (5.3 CVSS)
Note: UPnP was disabled by default after CVE-2015-6031
"""

import asyncio
import socket
import struct

from minesploit.framework import Exploit, ExploitMeta, ExploitResult


class CVE_2015_20111_MINIUPNPC_RCE(Exploit):
    meta = ExploitMeta(
        name="CVE-2015-20111: miniupnpc Buffer Overflow RCE",
        cve="CVE-2015-20111",
        cvss_score=5.3,
        severity="MEDIUM",
        affected_versions="Bitcoin Core < 0.12.0 with UPnP enabled",
        discovered_by="Wladimir J. Van Der Laan",
        disclosure_date="2024-07-03",
        description=(
            "A buffer overflow vulnerability in the miniupnpc library allows remote attackers "
            "on the local network to execute arbitrary code via malicious SSDP/UDP responses. "
            "The attack requires UPnP to be enabled on the target Bitcoin Core node. "
            "UPnP was disabled by default after CVE-2015-6031 disclosure."
        ),
        references=[
            "https://bitcoincore.org/en/2024/07/03/disclose_upnp_rce/",
            "https://nvd.nist.gov/vuln/detail/CVE-2015-20111",
        ],
    )

    def __init__(self):
        super().__init__()

    def _create_version_message(self, version: int = 70012) -> bytes:
        magic = b"\xf9\xbe\xb4\xd9"
        command = b"version\x00\x00\x00\x00\x00"

        payload = struct.pack("<I", version)
        payload += b"\x00" * 8
        payload += struct.pack("<Q", 0)
        payload += b"\x00" * 10
        payload += struct.pack("<Q", 0)
        payload += b"\x00" * 8
        payload += b"\x00"
        payload += b"\x00" * 10
        payload += b"\x00" * 24

        checksum = b"\x00\x00\x00\x00"

        return magic + command + struct.pack("<I", len(payload)) + checksum + payload

    def _parse_version_from_version_msg(self, data: bytes) -> str | None:
        try:
            if b"version\x00" in data or data[12:20] == b"version":
                if len(data) > 48:
                    version = struct.unpack("<I", data[40:44])[0]
                    return str(version)
            return None
        except Exception:
            return None

    async def _check_upnp_on_local_network(self, target: str) -> bool:
        try:
            ssdp_address = ("239.255.255.250", 1900)

            ssdp_msearch = (
                "M-SEARCH * HTTP/1.1\r\n"
                "HOST: 239.255.255.250:1900\r\n"
                'MAN: "ssdp:discover"\r\n'
                "MX: 3\r\n"
                "ST: upnp:rootdevice\r\n"
                "\r\n"
            )

            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            sock.settimeout(5.0)
            sock.sendto(ssdp_msearch.encode(), ssdp_address)

            try:
                response, addr = sock.recvfrom(4096)
                sock.close()
                return True
            except TimeoutError:
                sock.close()
                return False

        except Exception:
            return False

    async def _get_bitcoin_core_version(self, target: str, port: int) -> str | None:
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(target, port),
                timeout=10.0,
            )

            version_msg = self._create_version_message()
            writer.write(version_msg)
            await writer.drain()

            response = await asyncio.wait_for(reader.read(4096), timeout=10.0)

            writer.close()
            await writer.wait_closed()

            if response and len(response) > 48:
                return self._parse_version_from_version_msg(response)

            return None

        except Exception:
            return None

    async def check(self, target: str, port: int = 8333, **kwargs) -> ExploitResult:
        try:
            version = await self._get_bitcoin_core_version(target, port)

            version_num = None
            if version:
                try:
                    version_num = int(version)
                    if version_num >= 0x0C0000:
                        return ExploitResult(
                            False,
                            f"Bitcoin Core version {version} is patched (>= 0.12.0)",
                            {"vulnerable": False, "version": version, "upnp_available": None},
                        )
                except ValueError:
                    pass

            upnp_detected = await self._check_upnp_on_local_network(target)

            if version_num is not None:
                if version_num < 0x0C0000 and upnp_detected:
                    return ExploitResult(
                        True,
                        (
                            f"Bitcoin Core version {version} is VULNERABLE (< 0.12.0) "
                            "and UPnP is accessible on the local network. "
                            "Target may be exploitable if UPnP is enabled in Bitcoin Core."
                        ),
                        {"vulnerable": True, "version": version, "upnp_available": upnp_detected},
                    )
                elif version_num < 0x0C0000 and not upnp_detected:
                    return ExploitResult(
                        True,
                        (
                            f"Bitcoin Core version {version} is potentially vulnerable (< 0.12.0) "
                            "but UPnP was not detected on local network. "
                            "Target may still be vulnerable if UPnP is enabled locally."
                        ),
                        {"vulnerable": True, "version": version, "upnp_available": upnp_detected},
                    )

            if upnp_detected:
                return ExploitResult(
                    True,
                    (
                        "UPnP devices detected on local network. "
                        "If target Bitcoin Core has UPnP enabled and is < 0.12.0, "
                        "it may be vulnerable to CVE-2015-20111."
                    ),
                    {"vulnerable": None, "version": version, "upnp_available": upnp_detected},
                )

            return ExploitResult(
                False,
                "No vulnerable Bitcoin Core version detected and no UPnP devices found",
                {"vulnerable": False, "version": version, "upnp_available": upnp_detected},
            )

        except asyncio.TimeoutError:
            return ExploitResult(False, "Connection timed out")
        except ConnectionRefusedError:
            return ExploitResult(False, "Connection refused")
        except Exception as e:
            return ExploitResult(False, f"Error: {str(e)}")

    async def exploit(
        self,
        target: str,
        port: int = 8333,
        **kwargs,
    ) -> ExploitResult:
        return ExploitResult(
            True,
            (
                "CVE-2015-20111 requires a malicious UPnP server on the local network. "
                "The actual exploit involves sending specially crafted SSDP/UDP responses "
                "that trigger a buffer overflow in miniupnpc, combined with CVE-2015-6031 "
                "to achieve remote code execution. This is a complex attack requiring "
                "local network proximity and a malicious UPnP server implementation. "
                "Detection only - actual exploit requires custom UPnP server setup."
            ),
            {"exploit_sent": False, "complex_attack": True},
        )

    async def verify(self, target: str, port: int = 8333, **kwargs) -> ExploitResult:
        return ExploitResult(
            True,
            "Verification requires monitoring for unauthorized UPnP mappings and network traffic analysis",
        )
