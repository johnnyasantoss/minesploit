"""CVE-2024-52912: Bitcoin Core Timestamp Overflow Netsplit

This vulnerability allows remote attackers to cause a netsplit by manipulating
the node's time adjustment through the timedata module. Two bugs combined:

1. Signed-integer overflow when calculating time offset
2. abs64 logic bug: abs64(INT64_MIN) returns INT64_MIN instead of overflowing

Reference: https://bitcoincore.org/en/2024/07/03/disclose-timestamp-overflow/
Reference: https://nvd.nist.gov/vuln/detail/CVE-2024-52912

Affected: Bitcoin Core < 0.21.0
Severity: MEDIUM (5.3 CVSS)
Fixed In: Bitcoin Core 0.21.0 (January 15, 2021)
"""

import asyncio
import struct

from minesploit.framework import Exploit, ExploitMeta, ExploitResult


class CVE_2024_52912_TIMESTAMP_OVERFLOW(Exploit):
    meta = ExploitMeta(
        name="CVE-2024-52912: Bitcoin Core Timestamp Overflow",
        cve="CVE-2024-52912",
        cvss_score=5.3,
        severity="MEDIUM",
        affected_versions="Bitcoin Core < 0.21.0",
        discovered_by="practicalswift",
        disclosure_date="2024-07-03",
        description=(
            "Bitcoin Core before 0.21.0 has a timedata vulnerability that allows remote "
            "attackers to cause a netsplit via a timestamp manipulation attack. The attacker "
            "must be among the first 200 peers to connect to the victim. This can cause the "
            "victim's adjusted time to be severely skewed, leading to rejection of all new "
            "blocks as 'too far in the future'."
        ),
        references=[
            "https://bitcoincore.org/en/2024/07/03/disclose-timestamp-overflow/",
            "https://nvd.nist.gov/vuln/detail/CVE-2024-52912",
        ],
    )

    def __init__(self):
        super().__init__()

    async def check(self, target: str, port: int = 8333, **kwargs) -> ExploitResult:
        """Check if target Bitcoin Core version is vulnerable (< 0.21.0)"""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(target, port),
                timeout=10.0,
            )

            version_msg = self._create_version_message()
            writer.write(version_msg)
            await writer.drain()

            response = await asyncio.wait_for(reader.read(4096), timeout=10.0)

            writer.close()
            await writer.wait_closed()

            if not response or len(response) < 24:
                return ExploitResult(False, "No Bitcoin Core response detected")

            version = self._parse_version_from_response(response)

            if version is None:
                return ExploitResult(
                    False,
                    "Could not determine Bitcoin Core version",
                    {"raw_response": response[:200].hex()},
                )

            if version < (0, 21, 0):
                return ExploitResult(
                    True,
                    f"Vulnerable Bitcoin Core {self._version_str(version)} detected (< 0.21.0)",
                    {
                        "vulnerable": True,
                        "version": self._version_str(version),
                        "service": "bitcoind",
                    },
                )

            return ExploitResult(
                False,
                f"Bitcoin Core {self._version_str(version)} is not vulnerable (>= 0.21.0)",
                {
                    "vulnerable": False,
                    "version": self._version_str(version),
                    "service": "bitcoind",
                },
            )

        except asyncio.TimeoutError:
            return ExploitResult(False, "Connection timed out")
        except ConnectionRefusedError:
            return ExploitResult(False, "Connection refused")
        except Exception as e:
            return ExploitResult(False, f"Error: {str(e)}")

    def _create_version_message(self) -> bytes:
        magic = b"\xf9\xbe\xb4\xd9"
        command = b"version\x00\x00\x00\x00\x00"

        payload = struct.pack("<I", 70015)
        payload += b"\x00" * 8
        payload += struct.pack("<Q", 0)
        payload += b"\x00" * 10
        payload += struct.pack("<Q", 0)
        payload += b"\x00" * 8
        payload += b"\x00"
        payload += b"\x00" * 10
        payload += b"\x00" * 24

        checksum = b"\x00\x00\x00\x00"

        return magic + command + struct.pack("<I", len(payload)) + checksum + payload

    def _parse_version_from_response(self, response: bytes) -> tuple | None:
        if b"version\x00\x00\x00\x00\x00" in response:
            version_start = response.find(b"version\x00\x00\x00\x00\x00") + 16
            if version_start > 16 and len(response) >= version_start + 4:
                try:
                    version = struct.unpack("<I", response[version_start : version_start + 4])[0]
                    major = (version >> 16) & 0xFFFF
                    minor = (version >> 8) & 0xFF
                    patch = version & 0xFF
                    return (major, minor, patch)
                except Exception:
                    pass
        return None

    def _version_str(self, version: tuple) -> str:
        return f"{version[0]}.{version[1]}.{version[2]}"

    async def exploit(
        self,
        target: str,
        port: int = 8333,
        **kwargs,
    ) -> ExploitResult:
        return ExploitResult(
            False,
            (
                "Full exploitation of CVE-2024-52912 requires being among the first 200 "
                "peers to connect and significant resources to manipulate time data. "
                "This check only detects vulnerable versions."
            ),
        )

    async def verify(self, target: str, port: int = 8333, **kwargs) -> ExploitResult:
        return ExploitResult(
            True,
            "Version check performed - actual exploitation requires netsplit conditions",
        )
