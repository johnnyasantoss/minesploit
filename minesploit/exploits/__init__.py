"""Minesploit exploit modules - dynamically discovered"""

import importlib
import pkgutil
from typing import Any

from minesploit.database import register_exploit
from minesploit.framework import Exploit


def _discover_exploit_classes() -> dict[str, type[Exploit]]:
    """Discover all Exploit subclasses from cve_*.py modules in this package."""
    result: dict[str, type] = {}
    prefix = __name__ + "."
    for _importer, modname, _ispkg in pkgutil.iter_modules(__path__, prefix):
        if not modname.split(".")[-1].startswith("cve_"):
            continue
        try:
            mod = importlib.import_module(modname)
        except Exception:
            continue
        for attr_name in dir(mod):
            if attr_name.startswith("_"):
                continue
            obj = getattr(mod, attr_name)
            if (
                isinstance(obj, type)
                and issubclass(obj, Exploit)
                and obj is not Exploit
            ):
                key = modname.split(".")[-1]
                result[key] = obj
                register_exploit(obj.meta)
                break
    return result


EXPLOIT_CLASSES: dict[str, type] = _discover_exploit_classes()


def _scan_exploits() -> None:
    """No-op for database compatibility; discovery runs at import time."""
    pass


def __getattr__(name: str) -> Any:
    if name.startswith("_"):
        raise AttributeError(name)

    if name in EXPLOIT_CLASSES:
        return EXPLOIT_CLASSES[name]

    for cls in EXPLOIT_CLASSES.values():
        if cls.__name__ == name:
            return cls

    raise AttributeError(f"module {__name__!r} has no attribute {name!r}")


def __dir__() -> list[str]:
    names = set(EXPLOIT_CLASSES.keys())
    names.update(cls.__name__ for cls in EXPLOIT_CLASSES.values())
    return sorted(names)


__all__ = ["EXPLOIT_CLASSES"]
