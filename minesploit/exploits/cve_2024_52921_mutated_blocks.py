"""CVE-2024-52921: Hindered block propagation due to mutated blocks

This vulnerability allows remote attackers to hinder block propagation by
sending mutated blocks that clear the download state of other peers.

Reference: https://bitcoincore.org/en/2024/10/08/disclose-mutated-blocks-hindering-propagation/
Reference: https://nvd.nist.gov/vuln/detail/CVE-2024-52921

Affected: Bitcoin Core < 25.0
Severity: MEDIUM (5.3 CVSS)
"""

import asyncio
import struct

from minesploit.framework import Exploit, ExploitMeta, ExploitResult


class CVE_2024_52921_MUTATED_BLOCKS(Exploit):
    meta = ExploitMeta(
        name="CVE-2024-52921: Mutated Blocks Hindering Propagation",
        cve="CVE-2024-52921",
        cvss_score=5.3,
        severity="MEDIUM",
        affected_versions="Bitcoin Core < 25.0",
        discovered_by="Suhas Daftuar",
        disclosure_date="2024-10-08",
        description=(
            "Bitcoin Core before 25.0 contains a vulnerability where a peer sending mutated "
            "blocks can clear the download state of other peers, hindering block propagation. "
            "An attacker must send a mutated block between the block announcement and the "
            "arrival of the legitimate blocktxn response."
        ),
        references=[
            "https://bitcoincore.org/en/2024/10/08/disclose-mutated-blocks-hindering-propagation/",
            "https://nvd.nist.gov/vuln/detail/CVE-2024-52921",
        ],
    )

    def __init__(self):
        super().__init__()

    async def check(self, target: str, port: int = 8333, **kwargs) -> ExploitResult:
        """Check if target is running a vulnerable Bitcoin Core version.

        Note: Full exploitation requires precise timing between block announcement
        and blocktxn response arrival. This check verifies version via service detection.
        """
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(target, port),
                timeout=10.0,
            )

            version_msg = self._create_version_message()
            writer.write(version_msg)
            await writer.drain()

            response = await asyncio.wait_for(reader.read(4096), timeout=10.0)

            writer.close()
            await writer.wait_closed()

            if response and len(response) > 24:
                version = self._parse_version(response)
                if version:
                    if version < (25, 0):
                        return ExploitResult(
                            True,
                            f"Bitcoin Core {version} detected - vulnerable to CVE-2024-52921",
                            {"vulnerable": True, "version": version, "service": "bitcoind"},
                        )
                    else:
                        return ExploitResult(
                            False,
                            f"Bitcoin Core {version} detected - not vulnerable (>= 25.0)",
                            {"vulnerable": False, "version": version},
                        )

                return ExploitResult(
                    True,
                    "Bitcoin Core node detected - version unknown, may be vulnerable",
                    {"vulnerable": True, "service": "bitcoind"},
                )

            return ExploitResult(False, "No Bitcoin Core response detected")

        except asyncio.TimeoutError:
            return ExploitResult(False, "Connection timed out")
        except ConnectionRefusedError:
            return ExploitResult(False, "Connection refused")
        except Exception as e:
            return ExploitResult(False, f"Error: {str(e)}")

    def _parse_version(self, data: bytes) -> tuple | None:
        try:
            if b"version" in data:
                version_start = data.find(b"version") + 8
                if len(data) >= version_start + 86:
                    version = struct.unpack("<I", data[version_start + 76 : version_start + 80])[0]
                    if version > 100000:
                        major = (version // 100000) % 100
                        minor = (version // 1000) % 100
                        patch = version % 1000
                        return (major, minor, patch)
        except Exception:
            pass
        return None

    def _create_version_message(self) -> bytes:
        magic = b"\xf9\xbe\xb4\xd9"
        command = b"version\x00\x00\x00\x00\x00"

        payload = struct.pack("<I", 70015)
        payload += b"\x00" * 8
        payload += struct.pack("<Q", 0)
        payload += b"\x00" * 10
        payload += struct.pack("<Q", 0)
        payload += b"\x00" * 8
        payload += b"\x00"
        payload += b"\x00" * 10
        payload += b"\x00" * 24

        checksum = b"\x00\x00\x00\x00"

        return magic + command + struct.pack("<I", len(payload)) + checksum + payload

    async def exploit(
        self,
        target: str,
        port: int = 8333,
        **kwargs,
    ) -> ExploitResult:
        """Attempt to exploit the mutated block vulnerability.

        Note: This is highly timing-sensitive. Success depends on sending the
        mutated block within a narrow window between block announcement and
        the blocktxn response. In practice, this is difficult to exploit reliably.
        """
        return ExploitResult(
            False,
            (
                "Exploitation of CVE-2024-52921 is timing-sensitive and requires "
                "precise coordination with block propagation. Use check() to detect "
                "vulnerable versions. Manual testing with network timing required."
            ),
            {"timing_sensitive": True},
        )

    async def verify(self, target: str, port: int = 8333, **kwargs) -> ExploitResult:
        return ExploitResult(
            True,
            "Verification requires monitoring block propagation times",
        )
