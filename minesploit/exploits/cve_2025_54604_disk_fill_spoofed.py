"""CVE-2025-54604: Bitcoin Core Disk Fill from Spoofed Self Connections

This vulnerability allows remote attackers to cause a denial of service
(disk fill) via spoofed self-connections that trigger unlimited logging.

Reference: https://bitcoincore.org/en/2025/10/24/disclose-cve-2025-54604/
Reference: https://nvd.nist.gov/vuln/detail/CVE-2025-54604

Affected: Bitcoin Core < 29.1, < 30.0
Severity: LOW (3.7 CVSS)
"""

import asyncio
import re
import struct

from minesploit.framework import Exploit, ExploitMeta, ExploitResult


class CVE_2025_54604_DISK_FILL_SPOOFED(Exploit):
    meta = ExploitMeta(
        name="CVE-2025-54604: Bitcoin Core Disk Fill (Spoofed Self Connections)",
        cve="CVE-2025-54604",
        cvss_score=3.7,
        severity="LOW",
        affected_versions="Bitcoin Core < 29.1, < 30.0",
        discovered_by="Niklas Goegge",
        disclosure_date="2025-10-24",
        description=(
            "Bitcoin Core before 29.1 and 30.0 allows remote attackers to fill the disk "
            "via spoofed self-connections. The attacker captures the version nonce from an "
            "outbound connection initiated by the victim, then spoofs multiple incoming "
            "connections reusing the same nonce. Bitcoin Core unconditionally logs each "
            "'self-connection', allowing unlimited disk fill via log spam."
        ),
        references=[
            "https://bitcoincore.org/en/2025/10/24/disclose-cve-2025-54604/",
            "https://nvd.nist.gov/vuln/detail/CVE-2025-54604",
        ],
    )

    def __init__(self):
        super().__init__()

    def _parse_version(self, version_msg: bytes) -> tuple[str | None, int]:
        if len(version_msg) < 88:
            return None, 0

        try:
            payload_start = 24
            version = struct.unpack("<I", version_msg[payload_start : payload_start + 4])[0]

            user_agent_start = payload_start + 44
            user_agent_len = struct.unpack(
                "<B", version_msg[user_agent_start : user_agent_start + 1]
            )[0]

            if user_agent_start + 1 + user_agent_len <= len(version_msg):
                subver = version_msg[
                    user_agent_start + 1 : user_agent_start + 1 + user_agent_len
                ].decode("utf-8", errors="ignore")
                return subver, version

            return None, version
        except Exception:
            return None, 0

    def _parse_satoshi_version(self, subver: str) -> tuple[int, int, int] | None:
        match = re.search(r"/Satoshi:([^/]+)/", subver)
        if not match:
            return None
        version_str = match.group(1)
        parts = version_str.split(".")
        if len(parts) >= 2:
            try:
                major = int(parts[0])
                minor = int(parts[1])
                patch = int(parts[2]) if len(parts) > 2 else 0
                return (major, minor, patch)
            except ValueError:
                return None
        return None

    def _is_vulnerable(self, subver: str | None) -> bool:
        if not subver:
            return False

        version = self._parse_satoshi_version(subver)
        if not version:
            return False

        major, minor, patch = version
        if major < 29:
            return True
        if major == 29 and minor < 1:
            return True
        if major == 29 and minor == 1 and patch < 1:
            return True

        return False

    def _create_version_message(self, nonce: int = 0) -> bytes:
        magic = b"\xf9\xbe\xb4\xd9"
        command = b"version\x00\x00\x00\x00\x00"

        payload = struct.pack("<I", 70015)
        payload += struct.pack("<Q", 1)
        payload += struct.pack("<Q", int(asyncio.get_event_loop().time()) + 100000000)
        payload += b"\x01\x00\x00\x00\x00\x00\x00\x00"
        payload += b"\x01\x00\x00\x00\x00\x00\x00\x00"
        payload += struct.pack("<Q", nonce)
        payload += struct.pack("<B", 25)
        payload += b"/Minesploit:1.0.0/"
        payload += struct.pack("<I", 0)
        payload += struct.pack("<I", 0)

        checksum = b"\x00\x00\x00\x00"

        return magic + command + struct.pack("<I", len(payload)) + checksum + payload

    async def check(self, target: str, port: int = 8333, **kwargs) -> ExploitResult:
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(target, port),
                timeout=10.0,
            )

            version_msg = self._create_version_message()
            writer.write(version_msg)
            await writer.drain()

            response = await asyncio.wait_for(reader.read(4096), timeout=10.0)

            writer.close()
            await writer.wait_closed()

            if response and len(response) >= 88:
                subver, protocol_version = self._parse_version(response)
                vulnerable = self._is_vulnerable(subver)

                if subver:
                    version_info = f"subver: {subver}, protocol: {protocol_version}"
                else:
                    version_info = f"protocol version: {protocol_version}"

                if vulnerable:
                    return ExploitResult(
                        True,
                        f"Vulnerable Bitcoin Core detected: {version_info}",
                        {"vulnerable": True, "subver": subver, "service": "bitcoind"},
                    )
                else:
                    return ExploitResult(
                        False,
                        f"Bitcoin Core not vulnerable: {version_info}",
                        {"vulnerable": False, "subver": subver},
                    )

            return ExploitResult(False, "No valid Bitcoin Core version response")

        except asyncio.TimeoutError:
            return ExploitResult(False, "Connection timed out")
        except ConnectionRefusedError:
            return ExploitResult(False, "Connection refused")
        except Exception as e:
            return ExploitResult(False, f"Error: {str(e)}")

    async def exploit(
        self,
        target: str,
        port: int = 8333,
        **kwargs,
    ) -> ExploitResult:
        return ExploitResult(
            False,
            "Exploit not implemented - check() provides version detection. "
            "The actual attack requires victim to connect to attacker first and is slow.",
        )

    async def verify(self, target: str, port: int = 8333, **kwargs) -> ExploitResult:
        return ExploitResult(
            True,
            "Version detection completed - check node logs for 'self-connection' messages",
        )
